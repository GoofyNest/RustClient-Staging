public class ODQDQDQDQO : MonoBehaviour // TypeDefIndex: 7178
{

	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag) { }

	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p) { }

	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck) { }

	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint) { }

	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle) { }

	public static float GetYAngleByDir(Vector3 dir) { }

	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis) { }

	public static Vector3 OQQDCOCCCO(Vector3 source, float angle) { }

	public static int ODOCOCDQCO(List<Material> mats, Material mat) { }

	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up) { }

	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds) { }

	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr) { }

	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir) { }

	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir) { }

	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr) { }

	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend) { }

	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation) { }

	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation) { }

	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation) { }

	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation) { }

	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation) { }

	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3) { }

	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation) { }

	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray) { }

	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY) { }

	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers) { }

	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr) { }

	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr) { }

	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack) { }

	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep) { }

	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr) { }

	private static float Smooth(int x, int y, TerrainData terrainInfo) { }

	private static float Smooth1(float indent, float surrounding, float posY) { }

	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2) { }

	public static string CheckMesh(GameObject go) { }

	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren) { }

	public static List<float> OCOCDCOQCD(List<Vector2> nodes) { }

	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x) { }

	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2) { }

	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio) { }

	public static bool InIntArray(int v, List<int> arr) { }

	public static void OOQCCQCCCC(ERModularBase scr) { }

	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex) { }

	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint) { }

	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos) { }

	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir) { }

	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2) { }

	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag) { }

	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir) { }

	public static ERPoint ODCDDDCCDD(ERPoint source) { }

	public static void MergeVertices(Mesh m) { }

	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c) { }

	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2) { }

	public static bool FloatListComparer(List<float> list1, List<float> list2) { }

	public void .ctor() { }

}

