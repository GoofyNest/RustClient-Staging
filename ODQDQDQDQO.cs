public class ODQDQDQDQO : MonoBehaviour // TypeDefIndex: 7177
{	// Methods

	// RVA: 0xC01950 Offset: 0xBFFF50 VA: 0x180C01950
	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag) { }

	// RVA: 0xC03E80 Offset: 0xC02480 VA: 0x180C03E80
	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p) { }

	// RVA: 0xC03D20 Offset: 0xC02320 VA: 0x180C03D20
	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck) { }

	// RVA: 0xC04680 Offset: 0xC02C80 VA: 0x180C04680
	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint) { }

	// RVA: 0xC03FA0 Offset: 0xC025A0 VA: 0x180C03FA0
	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle) { }

	// RVA: 0xBFF140 Offset: 0xBFD740 VA: 0x180BFF140
	public static float GetYAngleByDir(Vector3 dir) { }

	// RVA: 0xC00550 Offset: 0xBFEB50 VA: 0x180C00550
	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis) { }

	// RVA: 0xC048C0 Offset: 0xC02EC0 VA: 0x180C048C0
	public static Vector3 OQQDCOCCCO(Vector3 source, float angle) { }

	// RVA: 0xC015B0 Offset: 0xBFFBB0 VA: 0x180C015B0
	public static int ODOCOCDQCO(List<Material> mats, Material mat) { }

	// RVA: 0xC000E0 Offset: 0xBFE6E0 VA: 0x180C000E0
	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up) { }

	// RVA: 0xC04230 Offset: 0xC02830 VA: 0x180C04230
	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds) { }

	// RVA: 0xC01720 Offset: 0xBFFD20 VA: 0x180C01720
	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr) { }

	// RVA: 0xC01120 Offset: 0xBFF720 VA: 0x180C01120
	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir) { }

	// RVA: 0xBFF890 Offset: 0xBFDE90 VA: 0x180BFF890
	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir) { }

	// RVA: 0xC027E0 Offset: 0xC00DE0 VA: 0x180C027E0
	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr) { }

	// RVA: 0xC01680 Offset: 0xBFFC80 VA: 0x180C01680
	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend) { }

	// RVA: 0xBFFCC0 Offset: 0xBFE2C0 VA: 0x180BFFCC0
	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC04100 Offset: 0xC02700 VA: 0x180C04100
	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation) { }

	// RVA: 0xC05780 Offset: 0xC03D80 VA: 0x180C05780
	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation) { }

	// RVA: 0xBFFA20 Offset: 0xBFE020 VA: 0x180BFFA20
	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC05270 Offset: 0xC03870 VA: 0x180C05270
	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation) { }

	// RVA: 0xC00900 Offset: 0xBFEF00 VA: 0x180C00900
	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3) { }

	// RVA: 0xBFF240 Offset: 0xBFD840 VA: 0x180BFF240
	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC058F0 Offset: 0xC03EF0 VA: 0x180C058F0
	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray) { }

	// RVA: 0xC001E0 Offset: 0xBFE7E0 VA: 0x180C001E0
	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY) { }

	// RVA: 0xBFE210 Offset: 0xBFC810 VA: 0x180BFE210
	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers) { }

	// RVA: 0xC01B90 Offset: 0xC00190 VA: 0x180C01B90
	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr) { }

	// RVA: 0xC01E80 Offset: 0xC00480 VA: 0x180C01E80
	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr) { }

	// RVA: 0xBFC7E0 Offset: 0xBFADE0 VA: 0x180BFC7E0
	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack) { }

	// RVA: 0xBFDA20 Offset: 0xBFC020 VA: 0x180BFDA20
	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xBFBA80 Offset: 0xBFA080 VA: 0x180BFBA80
	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xC06190 Offset: 0xC04790 VA: 0x180C06190
	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep) { }

	// RVA: 0xBFC020 Offset: 0xBFA620 VA: 0x180BFC020
	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr) { }

	// RVA: 0xC05FC0 Offset: 0xC045C0 VA: 0x180C05FC0
	private static float Smooth(int x, int y, TerrainData terrainInfo) { }

	// RVA: 0xC05F20 Offset: 0xC04520 VA: 0x180C05F20
	private static float Smooth1(float indent, float surrounding, float posY) { }

	// RVA: 0xBFC2A0 Offset: 0xBFA8A0 VA: 0x180BFC2A0
	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFBF30 Offset: 0xBFA530 VA: 0x180BFBF30
	public static string CheckMesh(GameObject go) { }

	// RVA: 0xC00C40 Offset: 0xBFF240 VA: 0x180C00C40
	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren) { }

	// RVA: 0xC00380 Offset: 0xBFE980 VA: 0x180C00380
	public static List<float> OCOCDCOQCD(List<Vector2> nodes) { }

	// RVA: 0xC01390 Offset: 0xBFF990 VA: 0x180C01390
	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x) { }

	// RVA: 0xBFB690 Offset: 0xBF9C90 VA: 0x180BFB690
	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC02A00 Offset: 0xC01000 VA: 0x180C02A00
	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio) { }

	// RVA: 0xBFF1B0 Offset: 0xBFD7B0 VA: 0x180BFF1B0
	public static bool InIntArray(int v, List<int> arr) { }

	// RVA: 0xC02040 Offset: 0xC00640 VA: 0x180C02040
	public static void OOQCCQCCCC(ERModularBase scr) { }

	// RVA: 0xC049D0 Offset: 0xC02FD0 VA: 0x180C049D0
	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex) { }

	// RVA: 0xBFC4A0 Offset: 0xBFAAA0 VA: 0x180BFC4A0
	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint) { }

	// RVA: 0xC00630 Offset: 0xBFEC30 VA: 0x180C00630
	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos) { }

	// RVA: 0xBFF0D0 Offset: 0xBFD6D0 VA: 0x180BFF0D0
	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir) { }

	// RVA: 0xC05640 Offset: 0xC03C40 VA: 0x180C05640
	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC05D00 Offset: 0xC04300 VA: 0x180C05D00
	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag) { }

	// RVA: 0xBFC610 Offset: 0xBFAC10 VA: 0x180BFC610
	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir) { }

	// RVA: 0xC012B0 Offset: 0xBFF8B0 VA: 0x180C012B0
	public static ERPoint ODCDDDCCDD(ERPoint source) { }

	// RVA: 0xBFF2E0 Offset: 0xBFD8E0 VA: 0x180BFF2E0
	public static void MergeVertices(Mesh m) { }

	// RVA: 0xC07400 Offset: 0xC05A00 VA: 0x180C07400
	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c) { }

	// RVA: 0xC07330 Offset: 0xC05930 VA: 0x180C07330
	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFC3D0 Offset: 0xBFA9D0 VA: 0x180BFC3D0
	public static bool FloatListComparer(List<float> list1, List<float> list2) { }

	// RVA: 0x2FA1F0 Offset: 0x2F87F0 VA: 0x1802FA1F0
	public void .ctor() { }

}

