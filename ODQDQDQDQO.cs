public class ODQDQDQDQO : MonoBehaviour // TypeDefIndex: 7177
{	// Methods

	// RVA: 0xC01C10 Offset: 0xC00210 VA: 0x180C01C10
	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag) { }

	// RVA: 0xC04140 Offset: 0xC02740 VA: 0x180C04140
	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p) { }

	// RVA: 0xC03FE0 Offset: 0xC025E0 VA: 0x180C03FE0
	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck) { }

	// RVA: 0xC04940 Offset: 0xC02F40 VA: 0x180C04940
	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint) { }

	// RVA: 0xC04260 Offset: 0xC02860 VA: 0x180C04260
	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle) { }

	// RVA: 0xBFF400 Offset: 0xBFDA00 VA: 0x180BFF400
	public static float GetYAngleByDir(Vector3 dir) { }

	// RVA: 0xC00810 Offset: 0xBFEE10 VA: 0x180C00810
	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis) { }

	// RVA: 0xC04B80 Offset: 0xC03180 VA: 0x180C04B80
	public static Vector3 OQQDCOCCCO(Vector3 source, float angle) { }

	// RVA: 0xC01870 Offset: 0xBFFE70 VA: 0x180C01870
	public static int ODOCOCDQCO(List<Material> mats, Material mat) { }

	// RVA: 0xC003A0 Offset: 0xBFE9A0 VA: 0x180C003A0
	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up) { }

	// RVA: 0xC044F0 Offset: 0xC02AF0 VA: 0x180C044F0
	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds) { }

	// RVA: 0xC019E0 Offset: 0xBFFFE0 VA: 0x180C019E0
	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr) { }

	// RVA: 0xC013E0 Offset: 0xBFF9E0 VA: 0x180C013E0
	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir) { }

	// RVA: 0xBFFB50 Offset: 0xBFE150 VA: 0x180BFFB50
	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir) { }

	// RVA: 0xC02AA0 Offset: 0xC010A0 VA: 0x180C02AA0
	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr) { }

	// RVA: 0xC01940 Offset: 0xBFFF40 VA: 0x180C01940
	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend) { }

	// RVA: 0xBFFF80 Offset: 0xBFE580 VA: 0x180BFFF80
	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC043C0 Offset: 0xC029C0 VA: 0x180C043C0
	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation) { }

	// RVA: 0xC05A40 Offset: 0xC04040 VA: 0x180C05A40
	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation) { }

	// RVA: 0xBFFCE0 Offset: 0xBFE2E0 VA: 0x180BFFCE0
	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC05530 Offset: 0xC03B30 VA: 0x180C05530
	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation) { }

	// RVA: 0xC00BC0 Offset: 0xBFF1C0 VA: 0x180C00BC0
	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3) { }

	// RVA: 0xBFF500 Offset: 0xBFDB00 VA: 0x180BFF500
	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC05BB0 Offset: 0xC041B0 VA: 0x180C05BB0
	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray) { }

	// RVA: 0xC004A0 Offset: 0xBFEAA0 VA: 0x180C004A0
	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY) { }

	// RVA: 0xBFE4D0 Offset: 0xBFCAD0 VA: 0x180BFE4D0
	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers) { }

	// RVA: 0xC01E50 Offset: 0xC00450 VA: 0x180C01E50
	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr) { }

	// RVA: 0xC02140 Offset: 0xC00740 VA: 0x180C02140
	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr) { }

	// RVA: 0xBFCAA0 Offset: 0xBFB0A0 VA: 0x180BFCAA0
	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack) { }

	// RVA: 0xBFDCE0 Offset: 0xBFC2E0 VA: 0x180BFDCE0
	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xBFBD40 Offset: 0xBFA340 VA: 0x180BFBD40
	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xC06450 Offset: 0xC04A50 VA: 0x180C06450
	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep) { }

	// RVA: 0xBFC2E0 Offset: 0xBFA8E0 VA: 0x180BFC2E0
	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr) { }

	// RVA: 0xC06280 Offset: 0xC04880 VA: 0x180C06280
	private static float Smooth(int x, int y, TerrainData terrainInfo) { }

	// RVA: 0xC061E0 Offset: 0xC047E0 VA: 0x180C061E0
	private static float Smooth1(float indent, float surrounding, float posY) { }

	// RVA: 0xBFC560 Offset: 0xBFAB60 VA: 0x180BFC560
	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFC1F0 Offset: 0xBFA7F0 VA: 0x180BFC1F0
	public static string CheckMesh(GameObject go) { }

	// RVA: 0xC00F00 Offset: 0xBFF500 VA: 0x180C00F00
	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren) { }

	// RVA: 0xC00640 Offset: 0xBFEC40 VA: 0x180C00640
	public static List<float> OCOCDCOQCD(List<Vector2> nodes) { }

	// RVA: 0xC01650 Offset: 0xBFFC50 VA: 0x180C01650
	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x) { }

	// RVA: 0xBFB950 Offset: 0xBF9F50 VA: 0x180BFB950
	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC02CC0 Offset: 0xC012C0 VA: 0x180C02CC0
	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio) { }

	// RVA: 0xBFF470 Offset: 0xBFDA70 VA: 0x180BFF470
	public static bool InIntArray(int v, List<int> arr) { }

	// RVA: 0xC02300 Offset: 0xC00900 VA: 0x180C02300
	public static void OOQCCQCCCC(ERModularBase scr) { }

	// RVA: 0xC04C90 Offset: 0xC03290 VA: 0x180C04C90
	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex) { }

	// RVA: 0xBFC760 Offset: 0xBFAD60 VA: 0x180BFC760
	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint) { }

	// RVA: 0xC008F0 Offset: 0xBFEEF0 VA: 0x180C008F0
	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos) { }

	// RVA: 0xBFF390 Offset: 0xBFD990 VA: 0x180BFF390
	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir) { }

	// RVA: 0xC05900 Offset: 0xC03F00 VA: 0x180C05900
	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC05FC0 Offset: 0xC045C0 VA: 0x180C05FC0
	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag) { }

	// RVA: 0xBFC8D0 Offset: 0xBFAED0 VA: 0x180BFC8D0
	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir) { }

	// RVA: 0xC01570 Offset: 0xBFFB70 VA: 0x180C01570
	public static ERPoint ODCDDDCCDD(ERPoint source) { }

	// RVA: 0xBFF5A0 Offset: 0xBFDBA0 VA: 0x180BFF5A0
	public static void MergeVertices(Mesh m) { }

	// RVA: 0xC076C0 Offset: 0xC05CC0 VA: 0x180C076C0
	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c) { }

	// RVA: 0xC075F0 Offset: 0xC05BF0 VA: 0x180C075F0
	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFC690 Offset: 0xBFAC90 VA: 0x180BFC690
	public static bool FloatListComparer(List<float> list1, List<float> list2) { }

	// RVA: 0x2FA1F0 Offset: 0x2F87F0 VA: 0x1802FA1F0
	public void .ctor() { }

}

