public class ODQDQDQDQO : MonoBehaviour // TypeDefIndex: 7177
{	// Methods

	// RVA: 0xC020E0 Offset: 0xC006E0 VA: 0x180C020E0
	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag) { }

	// RVA: 0xC04610 Offset: 0xC02C10 VA: 0x180C04610
	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p) { }

	// RVA: 0xC044B0 Offset: 0xC02AB0 VA: 0x180C044B0
	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck) { }

	// RVA: 0xC04E10 Offset: 0xC03410 VA: 0x180C04E10
	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint) { }

	// RVA: 0xC04730 Offset: 0xC02D30 VA: 0x180C04730
	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle) { }

	// RVA: 0xBFF8D0 Offset: 0xBFDED0 VA: 0x180BFF8D0
	public static float GetYAngleByDir(Vector3 dir) { }

	// RVA: 0xC00CE0 Offset: 0xBFF2E0 VA: 0x180C00CE0
	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis) { }

	// RVA: 0xC05050 Offset: 0xC03650 VA: 0x180C05050
	public static Vector3 OQQDCOCCCO(Vector3 source, float angle) { }

	// RVA: 0xC01D40 Offset: 0xC00340 VA: 0x180C01D40
	public static int ODOCOCDQCO(List<Material> mats, Material mat) { }

	// RVA: 0xC00870 Offset: 0xBFEE70 VA: 0x180C00870
	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up) { }

	// RVA: 0xC049C0 Offset: 0xC02FC0 VA: 0x180C049C0
	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds) { }

	// RVA: 0xC01EB0 Offset: 0xC004B0 VA: 0x180C01EB0
	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr) { }

	// RVA: 0xC018B0 Offset: 0xBFFEB0 VA: 0x180C018B0
	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir) { }

	// RVA: 0xC00020 Offset: 0xBFE620 VA: 0x180C00020
	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir) { }

	// RVA: 0xC02F70 Offset: 0xC01570 VA: 0x180C02F70
	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr) { }

	// RVA: 0xC01E10 Offset: 0xC00410 VA: 0x180C01E10
	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend) { }

	// RVA: 0xC00450 Offset: 0xBFEA50 VA: 0x180C00450
	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC04890 Offset: 0xC02E90 VA: 0x180C04890
	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation) { }

	// RVA: 0xC05F10 Offset: 0xC04510 VA: 0x180C05F10
	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation) { }

	// RVA: 0xC001B0 Offset: 0xBFE7B0 VA: 0x180C001B0
	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC05A00 Offset: 0xC04000 VA: 0x180C05A00
	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation) { }

	// RVA: 0xC01090 Offset: 0xBFF690 VA: 0x180C01090
	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3) { }

	// RVA: 0xBFF9D0 Offset: 0xBFDFD0 VA: 0x180BFF9D0
	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC06080 Offset: 0xC04680 VA: 0x180C06080
	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray) { }

	// RVA: 0xC00970 Offset: 0xBFEF70 VA: 0x180C00970
	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY) { }

	// RVA: 0xBFE9A0 Offset: 0xBFCFA0 VA: 0x180BFE9A0
	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers) { }

	// RVA: 0xC02320 Offset: 0xC00920 VA: 0x180C02320
	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr) { }

	// RVA: 0xC02610 Offset: 0xC00C10 VA: 0x180C02610
	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr) { }

	// RVA: 0xBFCF70 Offset: 0xBFB570 VA: 0x180BFCF70
	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack) { }

	// RVA: 0xBFE1B0 Offset: 0xBFC7B0 VA: 0x180BFE1B0
	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xBFC210 Offset: 0xBFA810 VA: 0x180BFC210
	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xC06920 Offset: 0xC04F20 VA: 0x180C06920
	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep) { }

	// RVA: 0xBFC7B0 Offset: 0xBFADB0 VA: 0x180BFC7B0
	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr) { }

	// RVA: 0xC06750 Offset: 0xC04D50 VA: 0x180C06750
	private static float Smooth(int x, int y, TerrainData terrainInfo) { }

	// RVA: 0xC066B0 Offset: 0xC04CB0 VA: 0x180C066B0
	private static float Smooth1(float indent, float surrounding, float posY) { }

	// RVA: 0xBFCA30 Offset: 0xBFB030 VA: 0x180BFCA30
	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFC6C0 Offset: 0xBFACC0 VA: 0x180BFC6C0
	public static string CheckMesh(GameObject go) { }

	// RVA: 0xC013D0 Offset: 0xBFF9D0 VA: 0x180C013D0
	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren) { }

	// RVA: 0xC00B10 Offset: 0xBFF110 VA: 0x180C00B10
	public static List<float> OCOCDCOQCD(List<Vector2> nodes) { }

	// RVA: 0xC01B20 Offset: 0xC00120 VA: 0x180C01B20
	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x) { }

	// RVA: 0xBFBE20 Offset: 0xBFA420 VA: 0x180BFBE20
	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC03190 Offset: 0xC01790 VA: 0x180C03190
	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio) { }

	// RVA: 0xBFF940 Offset: 0xBFDF40 VA: 0x180BFF940
	public static bool InIntArray(int v, List<int> arr) { }

	// RVA: 0xC027D0 Offset: 0xC00DD0 VA: 0x180C027D0
	public static void OOQCCQCCCC(ERModularBase scr) { }

	// RVA: 0xC05160 Offset: 0xC03760 VA: 0x180C05160
	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex) { }

	// RVA: 0xBFCC30 Offset: 0xBFB230 VA: 0x180BFCC30
	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint) { }

	// RVA: 0xC00DC0 Offset: 0xBFF3C0 VA: 0x180C00DC0
	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos) { }

	// RVA: 0xBFF860 Offset: 0xBFDE60 VA: 0x180BFF860
	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir) { }

	// RVA: 0xC05DD0 Offset: 0xC043D0 VA: 0x180C05DD0
	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC06490 Offset: 0xC04A90 VA: 0x180C06490
	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag) { }

	// RVA: 0xBFCDA0 Offset: 0xBFB3A0 VA: 0x180BFCDA0
	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir) { }

	// RVA: 0xC01A40 Offset: 0xC00040 VA: 0x180C01A40
	public static ERPoint ODCDDDCCDD(ERPoint source) { }

	// RVA: 0xBFFA70 Offset: 0xBFE070 VA: 0x180BFFA70
	public static void MergeVertices(Mesh m) { }

	// RVA: 0xC07B90 Offset: 0xC06190 VA: 0x180C07B90
	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c) { }

	// RVA: 0xC07AC0 Offset: 0xC060C0 VA: 0x180C07AC0
	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBFCB60 Offset: 0xBFB160 VA: 0x180BFCB60
	public static bool FloatListComparer(List<float> list1, List<float> list2) { }

	// RVA: 0x2FA1F0 Offset: 0x2F87F0 VA: 0x1802FA1F0
	public void .ctor() { }

}

